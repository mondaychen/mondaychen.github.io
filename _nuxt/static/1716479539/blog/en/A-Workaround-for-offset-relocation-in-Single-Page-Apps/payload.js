__NUXT_JSONP__("/blog/en/A-Workaround-for-offset-relocation-in-Single-Page-Apps", {data:[{html:"\u003Cp\u003EIt's a shared view that a single-page application (SPA) offers users better experience. However, in order to gain the benefits, developers have to take care of a lot of details ourselves. Browser's navigation (back\u002Fforward) is one of them.\u003C\u002Fp\u003E\n\u003Cp\u003EWeb applications often provide linkable, bookmarkable, shareable URLs for important locations in the app. In an SPA, either \u003Ca href=\"https:\u002F\u002Fcss-tricks.com\u002Fusing-the-html5-history-api\u002F\"\u003EHTML5 History API\u003C\u002Fa\u003E or hash fragments (\u003Ccode\u003E#page\u003C\u002Fcode\u003E) is used to provide these permalinks. When a \u003Ccode\u003Epopstate\u003C\u002Fcode\u003E or \u003Ccode\u003Ehashchange\u003C\u002Fcode\u003E event is triggered, a listener function is executed, changing some part of the page instead of loading another page. A typical way (using jQuery) to replace content of the page when a route is matched is like this:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003Evar $container = $('#container');\n...\n\u002F\u002F when some route is matched\nvar view = new AnotherPage();\n$container.html(view.render().el);\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch2\u003EThe problem\u003C\u002Fh2\u003E\n\u003Cp\u003EHere's the problem: if content in \u003Ccode\u003Eel\u003C\u002Fcode\u003E is bigger than window height, user can scroll down to a certain position. The next time \u003Ccode\u003Eel\u003C\u002Fcode\u003E replace content of \u003Ccode\u003E$container\u003C\u002Fcode\u003E, the browser stays at that position. We should tell the browser to go back to the top, just like when it loads a new page. The code is pretty simple:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003Ewindow.scrollTo(0, 0)\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EAnd then browser always scroll to top whenever a route is matched and the content is replaced.\u003C\u002Fp\u003E\n\u003Cp\u003EIt works perfectly, until the user clicks the back\u002Fforward button. In this case, the browser is supposed to scroll back to where it was before. Actually it still does so, but \u003Ccode\u003Ewindow.scrollTo(0, 0)\u003C\u002Fcode\u003E tells it to go to the top. You will probably notice that the browser goes back to where it was at first and after a galance it scrolls to the top again.\u003C\u002Fp\u003E\n\u003Cp\u003EI have tried many different ways to solve this problem. A straight-forward idea is to calculate the correct position instead of 0. I even implenmented a histroy manager toolkit to keep track of all history visits and positions. However, it turns out the best way is the opposite:\u003C\u002Fp\u003E\n\u003Cp\u003EOnly run \u003Ccode\u003EscrollTo\u003C\u002Fcode\u003E when it's necessary.\u003C\u002Fp\u003E\n\u003Cp\u003EHere's how: \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fmondaychen\u002Fmondaychen.github.io\u002Fblob\u002Fmaster\u002Fjs\u002Fapp\u002Fhistory-position.js\"\u003Ehttps:\u002F\u002Fgithub.com\u002Fmondaychen\u002Fmondaychen.github.io\u002Fblob\u002Fmaster\u002Fjs\u002Fapp\u002Fhistory-position.js\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Ch2\u003EExplanation\u003C\u002Fh2\u003E\n\u003Cp\u003EI use a variable \u003Ccode\u003ElastUserJump\u003C\u002Fcode\u003E to store the url\u002Ffragment from links. For example, when the user clicks \u003Ccode\u003E&lt;a href=&quot;#page&quot;&gt;Page Link&lt;\u002Fa&gt;\u003C\u002Fcode\u003E, \u003Ccode\u003ElastUserJump\u003C\u002Fcode\u003E is set to \u003Ccode\u003E&quot;page&quot;\u003C\u002Fcode\u003E. Then I have:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E$container.html(el)\n\u002F\u002F jump to top if needed\nif (historyManager.isUserJump(Backbone.history.fragment)) {\n  window.scrollTo(0, 0)\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EOnly when the new URL equals \u003Ccode\u003ElastUserJump\u003C\u002Fcode\u003E, tell browser to scroll to top. Since back\u002Fforward buttons do not set \u003Ccode\u003ElastUserJump\u003C\u002Fcode\u003E, it will allow the browser to position correctly.\u003C\u002Fp\u003E\n\u003Ch2\u003EStill not good enough!\u003C\u002Fh2\u003E\n\u003Cp\u003ENow theoretically it is perfect: it goes to the top when the user clicks on a link, and stays at the right position when the user clicks back\u002Fforward buttons (or keyboard control; anything not links). However, \u003Ccode\u003Eel\u003C\u002Fcode\u003E could be very long, and scroll offsets can be big numbers. If the earlier offset is bigger than current window height, the browser can not jump to the correct position. One way to avoid this is the following:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u002F\u002F make body long enough to help browser jump to the right position\n$body.css('min-height', '99999px')\n\u002F\u002F set dom\n$container.html(el)\n\u002F\u002F jump to top if needed\nif (historyManager.isUserJump(Backbone.history.fragment)) {\n  window.scrollTo(0, 0)\n}\n\u002F\u002F after 0.1s set min-height to a normal value\n\u002F\u002F hopefully no one will notice that\n_.delay(function () {\n  $body.css('min-height', '450px')\n}, 100)\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EFinally you can have it: a website that runs faster, and still have nice navigation experience.\u003C\u002Fp\u003E\n",title:"A Workaround for offset re-location in Single-Page Apps",time:1436500401017,location:"New York",links:[]}],fetch:{},mutations:void 0});